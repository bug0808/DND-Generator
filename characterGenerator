import random

# Can be part of the lightweight character generator or full character generator
# This code generates a character with a set of stats based on the class chosen.
def generate_stats_for_class(class_name):
    stat_profiles = {
        "Wizard": ["INT", "CON", "DEX", "WIS", "CHA", "STR"],
        "Fighter": ["STR", "CON", "DEX", "WIS", "CHA", "INT"],
        "Rogue": ["DEX", "INT", "CON", "WIS", "CHA", "STR"],
        "Cleric": ["WIS", "CON", "STR", "CHA", "DEX", "INT"],
        "Bard": ["CHA", "DEX", "CON", "INT", "WIS", "STR"],
        "Ranger": ["DEX", "WIS", "CON", "STR", "CHA", "INT"],
        "Paladin": ["STR", "CHA", "CON", "WIS", "DEX", "INT"],
        "Monk": ["DEX", "WIS", "CON", "STR", "CHA", "INT"],
        "Druid": ["WIS", "CON", "DEX", "INT", "CHA", "STR"],
        "Warlock": ["CHA", "CON", "DEX", "WIS", "INT", "STR"],
        "Sorcerer": ["CHA", "CON", "DEX", "WIS", "INT", "STR"],
        "Barbarian": ["STR", "CON", "DEX", "WIS", "CHA", "INT"],
        "Artificer": ["INT", "CON", "DEX", "WIS", "CHA", "STR"]
    }

    if class_name not in stat_profiles:
        raise ValueError("Unknown class name")

    ordered_stats = stat_profiles[class_name]
    point_array = [15, 14, 13, 10, 8, 8]

    final_stats = {stat: point_array[i] for i, stat in enumerate(ordered_stats)}

    return final_stats


stat_profiles = {
    "Wizard": ["INT", "CON", "DEX", "WIS", "CHA", "STR"],
    "Fighter": ["STR", "CON", "DEX", "WIS", "CHA", "INT"],
    "Rogue": ["DEX", "INT", "CON", "WIS", "CHA", "STR"],
    "Cleric": ["WIS", "CON", "STR", "CHA", "DEX", "INT"],
    "Bard": ["CHA", "DEX", "CON", "INT", "WIS", "STR"],
    "Ranger": ["DEX", "WIS", "CON", "STR", "CHA", "INT"],
    "Paladin": ["STR", "CHA", "CON", "WIS", "DEX", "INT"],
    "Monk": ["DEX", "WIS", "CON", "STR", "CHA", "INT"],
    "Druid": ["WIS", "CON", "DEX", "INT", "CHA", "STR"],
    "Warlock": ["CHA", "CON", "DEX", "WIS", "INT", "STR"],
    "Sorcerer": ["CHA", "CON", "DEX", "WIS", "INT", "STR"],
    "Barbarian": ["STR", "CON", "DEX", "WIS", "CHA", "INT"],
    "Artificer": ["INT", "CON", "DEX", "WIS", "CHA", "STR"]
}

class_table = {
    range(1, 7): "Barbarian",
    range(8, 14): "Bard",
    range(15, 21): "Cleric",
    range(22, 28): "Druid",
    range(29, 35): "Fighter",
    range(36, 42): "Monk",
    range(43, 49): "Paladin",
    range(50, 56): "Ranger",
    range(57, 63): "Rogue",
    range(64, 70): "Sorcerer",
    range(71, 77): "Warlock",
    range(78, 84): "Wizard",
    range(85, 91): "Artificer",
    range(92, 100): "Dealer's Choice"
}


# Define a Common race table
race_table_common = {
    range(1, 11): "Human",
    range(11, 21): "Elf",
    range(21, 31): "Dwarf",
    range(31, 41): "Halfling",
    range(41, 51): "Half-Orc",
    range(51, 61): "Gnome",
    range(61, 71): "Half-Elf",
    range(71, 81): "Dragonborn",
    range(81, 91): "Tiefling",
    range(91, 100): "Exotic"
}

race_table_exotic = {
    range(1, 11): "Warforged",
    range(11, 21): "Tortle",
    range(21, 31): "Aasimar",
    range(31, 41): "Firbolg",
    range(41, 51): "Genasi",
    range(51, 61): "Goliath",
    range(61, 71): "Kobold",
    range(71, 81): "Tabaxi",
    range(81, 91): "Triton",
    range(91, 100): "Kenku"
}

# Define racial bonuses   
#TODO: Add subrace stuff
#TODO: fix bonuses 
#TODO: Have it pick a random type of genasi
racial_bonuses = {
    "Human": {"STR": 1, "DEX": 1, "CON": 1, "INT": 1, "WIS": 1, "CHA": 1},
    "Elf": {"DEX": 2},
    "Dwarf": {"CON": 2},
    "Halfling": {"DEX": 2},
    "Half-Orc": {"STR": 2, "CON": 1},
    "Gnome": {"INT": 2},
    "Half-Elf": {"CHA": 2, "DEX": 1, "CON": 1}, # Assuming Half-Elf gets DEX and CON bonuses(possible future randomization)
    "Dragonborn": {"STR": 2, "CHA": 1},
    "Tiefling": {"CHA": 2},
    "Warforged": {"CON": 2, "STR": 1}, #Assuming it gets STR Bonus
    "Tortle": {"CON": 2, "WIS": 1}, # increase one score by 2 and increase a different score by 1, or increase three different scores by 1
    "Aasimar": {"CHA": 2, "WIS": 1}, # increase one score by 2 and increase a different score by 1, or increase three different scores by 1
    "Firbolg": {"WIS": 2, "STR": 1}, # increase one score by 2 and increase a different score by 1, or increase three different scores by 1
    "Genasi": {"CON": 2, "DEX": 1}, # increase one score by 2 and increase a different score by 1, or increase three different scores by 1
    "Goliath": {"STR": 2, "CON": 1}, # increase one score by 2 and increase a different score by 1, or increase three different scores by 1
    "Kobold": {"DEX": 2, "CHA": 1}, # increase one score by 2 and increase a different score by 1, or increase three different scores by 1
    "Tabaxi": {"DEX": 2, "CHA": 1}, # Volos Guide to Monsters
    "Triton": {"STR": 1, "CON": 1, "WIS": 1}, # Volos Guide to Monsters
    "Kenku": {"DEX": 2, "WIS": 1}, # Volos Guide to Monsters
}

#TODO: Edit to fit the common backstory table
#TODO: Add more backstories
#TODO CHANGE BACKSTORIES TO BE INDIVIDUAL TABLES TIED TO A BACKGROUND NOT THE OTHER WAY AROUND
# Define a sample backstory table
backstory_table = {
    1: ("Escaped a noble family scandal; hiding under a false identity", "Charlatan"),
    2: ("Grew up in a traveling circus as an acrobat and storyteller", "Entertainer"),
    3: ("Was a squire to a fallen paladin; now seeks redemption", "Acolyte or Knight of the Order"),
    4: ("Deserted the army after a tragic massacre", "Soldier"),
    5: ("Spent a decade as a librarian in a ruined temple of knowledge", "Sage"),
    6: ("Ex-convict turned bounty hunter", "Criminal or Urban Bounty Hunter"),
    7: ("Born with a celestial birthmark believed to be an omen", "Acolyte or Haunted One"),
    8: ("Ex-cultist turned truth-seeker", "Hermit or Acolyte"),
    9: ("Ran a shady potion shop; wants to go “legit”", "Guild Artisan or Charlatan"),
    10: ("Was shipwrecked as a child and raised by coastal druids", "Hermit or Far Traveler"),
    # entries 11–50 similar pattern 
}


def get_from_table(roll, table):
    for key_range, value in table.items():
        if roll in key_range:
            return value
    return None


def generate_stats_with_race(class_name, race_name):
    if class_name not in stat_profiles:
        print(class_name)
        raise ValueError("Unknown class name")
    if race_name not in racial_bonuses:
        raise ValueError("Unknown race name")

    ordered_stats = stat_profiles[class_name]
    point_array = [15, 14, 13, 10, 8, 8] # Base stats from point buy
    #TODO: Add some randomization to the point array maybe havve it simulate rolling 4d6 drop lowest
    # Base stats from point buy
    base_stats = {stat: point_array[i] for i, stat in enumerate(ordered_stats)}

    # Apply racial bonuses
    for stat, bonus in racial_bonuses[race_name].items():
        base_stats[stat] += bonus

    return base_stats


def generate_npc():
    class_roll = random.randint(1, 100)
    race_roll = random.randint(1, 100)
    backstory_roll = random.randint(1, 10)

    char_class = get_from_table(class_roll, class_table)
    race = get_from_table(race_roll, race_table_common)
    if race == "Exotic":
        race = get_from_table(random.randint(1, 100), race_table_exotic)
    backstory, background = backstory_table[backstory_roll]

    if char_class == "Dealer's Choice":
        char_class = random.choice(list(stat_profiles.keys()))

    stats = generate_stats_with_race(char_class, race)

    return {
        "Class": char_class,
        "Race": race,
        "Stats": stats,
        "Backstory": backstory,
        "Background": background
    }

# Generate example NPC
n = generate_npc()
print(n)
#TODO: Add a way to save the generated NPC to a file
#TODO: Add a way to load the generated NPC from a file
#TODO: Add a way to edit the generated NPC
#TODO: Add a way to delete the generated NPC
#TODO: Add a way to view the generated NPC
#TODO: Change the way stats are displayed to follow D&D Conventions
#TODO: Add backstory stats and proficiencies
#TODO: Maybe add a chatgpt wrapper to allow for more complex backstories